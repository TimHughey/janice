{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "defmodule Mcp.I2cSensor do\n\n#    Master Control Program for Wiss Landing\n#    Copyright (C) 2016  Tim Hughey (thughey)\n\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; \n even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>\n\n  use Timex\n  use Mcp.GenServer\n  use Bitwise\n\n  require Logger\n\n  defmodule State do\n    @unset :nil\n    @never :never\n    @complete :complete\n    @in_progress :in_progres\n    @ts :ts\n    @kickstarted :kickstarted\n    @i2c_dev_exists :i2c_dev_exists\n    @available :available\n    @status :status\n    @pids :pids\n    @sht_pid :sht_pid\n    @hih_pid :hih_pid\n    @sensors :sensors\n    @readings :readings\n    @sht :sht\n    @hih :hih\n\n    defstruct kickstarted: %{@ts =>Timex.zero, @status => @never},\n      i2c_dev_exists: %{@ts => Timex.zero(), @status => :false},\n      available: %{@ts => Timex.zero, @status => @never},\n      temp_cycle: %{@ts => Timex.zero, @status => @never},\n      pids: %{@sht_pid => @unset, @hih_pid => @unset},\n      sensors: [],\n      readings: %{ @sht => %{}, @hih => %{} }\n\n    def kickstarted(%State{} = state) do\n      %State{state | @kickstarted => status_tuple(@complete)}\n    end\n\n    def i2c_dev_exists?(%State{} = state), do: state.i2c_dev_exists.status\n    def confirm_i2c_dev(%State{} = state) do\n      case File.exists?(Mcp.I2cSensor.config(:i2c_device)) do\n        :true   -> %State{state | @i2c_dev_exists => %{@ts => Timex.now(), @status => :true}}\n        :false  -> %State{state | @i2c_dev_exists => %{@ts => Timex.now(), @status => :false}}\n      end\n      # returns state\n    end\n\n    def available?(state) when is_map(state) do\n      case state.available.status do\n        :never -> :false\n        :ok -> :true\n        :failed -> :false\n       end\n    end\n    def set_available(state), do: set_available(state, is_available?())\n    defp set_available(state, a) do\n      %State{state | @available => status_tuple(a)}\n    end\n    defp is_available? do\n      :ok\n    end\n\n    def set_pids(state, sht_pid, hih_pid) when is_map(state) do\n      pids = %{@sht_pid => sht_pid, @hih_pid => hih_pid}\n      %State{state | @pids => pids}\n    end\n\n    def get_sht_pid(state) when is_map(state) do\n      state.pids.sht_pid\n    end\n\n    def get_hih_pid(state) when is_map(state) do\n      state.pids.hih_pid\n    end\n\n    def set_sensors(state, sensors) when is_map(state) and is_list(sensors) do\n      %State{state | @sensors => sensors}\n    end\n\n    def get_sensors(state) when is_map(state) do\n      Enum.into(state.sensors, [], fn x -> x.name end)\n    end\n\n    def get_sensor_device(%State{} = state, name) when is_binary(name) do\n      sensor = Enum.find(state.sensors, fn x -> x.name == name end)\n      sensor.device\n    end\n\n    def temp_cycle_start(state) when is_map(state), do: set_temp_cycle(state, @in_progress)\n    def temp_cycle_end(state) when is_map(state),  do: set_temp_cycle(state, @complete)\n    defp set_temp_cycle(state, v) do\n      %State{state | temp_cycle: status_tuple(v)}\n    end\n    def temp_cycle_recent?(%State{} = state) do\n      elapsed_ms = Timex.diff(state.temp_cycle.ts, Timex.now(), :milliseconds) |> trunc\n      upper_bound = 1000\n      status = state.temp_cycle.status\n      serial = temp_cycle_serial(state)\n\n      case {elapsed_ms, status} do\n        {x, @complete} when x < 0                       -> {:false, serial}\n        {x, @complete} when x >= 0 and x <= upper_bound -> {:true, serial}\n        {x, @complete} when x >= 0 and x > upper_bound  -> {:false, serial}\n        {_ignored, @never}                              -> {:false, serial}\n        {_ignored, @in_progress}                        -> {:false, serial}\n      end\n    end\n    def temp_cycle_serial(state) when is_map(state) do\n      state.temp_cycle.ts |> Timex.to_gregorian_microseconds() |> trunc\n    end\n\n    def set_sht_reading(%State{} = state, reading) when is_map(reading) do\n      set_reading(state, @sht, reading)\n    end\n\n    def set_hih_reading(%State{} = state, reading) when is_map(reading) do\n      set_reading(state, @hih, reading)\n    end\n\n    defp set_reading(%State{} = state, dev, reading)\n    when is_atom(dev) and is_map(reading) do\n      readings = state.readings\n\n      readings = %{readings | dev => reading}\n      %State{state | @readings => readings}\n    end\n\n    def get_sht_reading(%State{} = state), do: get_reading(state, @sht)\n    def get_hih_reading(%State{} = state), do: get_reading(state, @hih)\n\n    def get_reading(%State{} = state, dev) do\n      state.readings[dev]\n    end\n\n    defp status_tuple(v), do: ts_tuple(@status, v)\n    defp ts_tuple(k, v) when is_atom(k) do\n      %{@ts => Timex.now, k => v}\n    end\n\n  end\n\n  defmodule Reading do\n    defstruct name: \"noname\", reading: \"noreading\", val: 0.0,\n      read_at: Timex.epoch(),\n      ts: Timex.now(),\n      elapsed_read_us: 0\n  end\n\n  @temperature \"temperature\"\n  @humidity \"humidity\"\n\n  # definition of messages that can be sent to this server\n  @available_msg :available?\n  @sensor_list_msg :get_sensor_list\n  @sensor_and_reading_list_msg :get_sensor_and_reading_list\n  @get_sensor_reading_msg :get_sensor_reading\n  @temp_cycle_start_msg :temp_convert_start\n  @temp_cycle_end_msg :temp_convert_end\n  @temp_available_msg :temp_available?\n  @temp_cycle_serial_num_msg :temp_serial_num\n  # @true_string \"1\"\n  # @false_string \"0\"\n\n  defp call_timeout_ms, do: config(:call_timeout_ms)\n  defp temp_refresh_ms, do: config(:temp_refresh_ms)\n  defp temp_cycle_wait_ms, do: sht_wait_ms() + hih_wait_ms()\n  defp kickstart_wait_ms, do: config(:kickstart_wait_ms)\n  defp i2c_device, do: config(:i2c_device)\n  defp sht_addr, do: config(:sht).address\n  defp sht_name, do: config(:sht).name\n  defp sht_wait_ms, do: config(:sht).wait_ms\n  defp hih_addr, do: config(:hih).address\n  defp hih_name, do: config(:hih).name\n  defp hih_wait_ms, do: config(:hih).wait_ms\n\n  @doc \"\"\"\n  Traditional implemenation of start_link\n  \"\"\"\n  def start_link(_args) do\n    state = State.set_available(%State{})\n    start_link(Mcp.I2cSensor, config(:name), state)\n  end\n\n  def init(state) do\n    Process.send_after(self(), @temp_cycle_start_msg, kickstart_wait_ms())\n    sensors = [\n        %{name: sht_name(), device: :sht},\n        %{name: hih_name(), device: :hih} ]\n\n    state = State.set_sensors(state, sensors) |> State.kickstarted()\n\n    {:ok, state}\n  end\n\n  defp start_i2c(%State{} = state) do\n      State.confirm_i2c_dev(state) |> start_i2c(State.i2c_dev_exists?(state))\n  end\n  defp start_i2c(%State{} = state, :true) do\n    {:ok, sht_pid} =\n      case State.get_sht_pid(state) do\n        :nil  -> I2c.start_link(i2c_device(), sht_addr())\n        _any  -> {:ok, State.get_sht_pid(state)}\n      end\n\n    {:ok, hih_pid} =\n      case State.get_hih_pid(state) do\n        :nil  -> I2c.start_link(i2c_device(), hih_addr())\n        _any  -> {:ok, State.get_hih_pid(state)}\n      end\n\n    State.set_pids(state, sht_pid, hih_pid)\n  end\n  defp start_i2c(%State{} = state, :false) do\n    State.get_sht_pid(state) |> I2c.release()\n    State.get_hih_pid(state) |> I2c.release()\n    State.set_pids(state, :nil, :nil)\n  end\n\n  def available? do\n    GenServer.call(server_name(), {@available_msg}, call_timeout_ms())\n  end\n\n  def temp_cycle_done?() do\n    GenServer.call(server_name(), @temp_available_msg, call_timeout_ms())\n  end\n\n  def temp_cycle_serial_num() do\n    GenServer.call(server_name(), @temp_cycle_serial_num_msg, call_timeout_ms())\n  end\n\n  def recommended_next_temp_ms(), do: temp_refresh_ms() + temp_cycle_wait_ms()\n\n  def known_sensor?(name) when is_binary(name), do: Regex.match?(~r/i2c/, name)\n\n  def read_sensor(name) when is_binary(name) do\n    GenServer.call(server_name(), {@get_sensor_reading_msg, name}, call_timeout_ms())\n  end\n\n  def sensor_list(pattern \\\\ :nil) do\n    case GenServer.whereis(server_name()) do\n      :nil -> no_server(\"I2cSensor.sensor_list\")\n      _ -> GenServer.call(server_name(), {@sensor_list_msg, pattern}, call_timeout_ms())\n    end\n  end\n\n  def sensor_and_reading_list(pattern) do\n    GenServer.call(server_name(), {@sensor_and_reading_list_msg, pattern}, call_timeout_ms())\n  end\n\n  #\n  # HANDLE CALL / HANDLE CAST\n  #\n  def handle_call({@available_msg}, _from, state) do\n    state = State.set_available(state)\n    {:reply, State.available?(state), state}\n  end\n\n  def handle_call(@temp_available_msg, _from, state) do\n    {:reply, State.temp_cycle_recent?(state), state}\n  end\n\n  def handle_call(@temp_cycle_serial_num_msg, _from, state) do\n    {:reply, State.temp_cycle_serial(state), state}\n  end\n\n  def handle_call({@get_sensor_reading_msg, name}, _from, state) do\n    result = do_read_sensor(state, name)\n\n    {:reply, result, state}\n  end\n\n  def handle_call({@sensor_list_msg, _regex}, _from, state) do\n    sensors = State.get_sensors(state)\n    {:reply, sensors, state}\n  end\n\n  def handle_call({@sensor_and_reading_list_msg, _regex}, _from, state) do\n    sensors = State.get_sensors(state)\n\n    list =\n      for sensor <- sensors do\n        for reading <- available_readings(sensor) do\n          %{name: sensor, reading: reading}\n        end\n      end |> List.flatten\n\n    {:reply, list, state}\n  end\n\n  def handle_info(@temp_cycle_start_msg, state) do\n    state = start_i2c(state)\n    state = State.temp_cycle_start(state)\n\n    sht_full = sht_trigger(State.get_sht_pid(state))\n    hih_full = hih_trigger(State.get_hih_pid(state))\n\n    state = State.set_sht_reading(state, sht_full)\n    state = State.set_hih_reading(state, hih_full)\n\n    Process.send_after(self(), @temp_cycle_end_msg, 1)\n    {:noreply, state}\n  end\n\n  def handle_info(@temp_cycle_end_msg, state) do\n    state = State.temp_cycle_end(state)\n\n    Process.send_after(self(), @temp_cycle_start_msg, temp_refresh_ms())\n    {:noreply, state}\n  end\n\n  defp available_readings(name) when is_binary(name) do\n    # TODO this should check the name is one I2cSensor handles\n    [ @temperature, @humidity ]\n  end\n\n  defp reading_map(elapsed_us, val, name, reading, checksum)\n  when is_binary(name) and is_binary(reading) do\n    dt = Timex.now()\n    ts = (Timex.now() |> Timex.to_unix()) * :math.pow(10,6) |> trunc\n    %{name: name, reading: reading,\n      val: val, read_at: dt, ts: ts, eus: elapsed_us, checksum: checksum}\n  end\n\n  defp hih_trigger(:nil), do: full_reading_map(0.0, 0.0, 0.0, :none, :none, :stale)\n  defp hih_trigger(pid) do\n    I2c.write(pid, <<0x27>>)\n    :ok = :timer.sleep(100)\n\n    <<humH, humL, temH, temL>> = I2c.read(pid, 4)\n\n    status =\n      case hih_decode_status(humH) do\n        0 -> :ok\n        1 -> :stale\n        2 -> :cmd_mode\n        _ -> :diagnostic\n      end\n\n    celsius = :binary.decode_unsigned(<<temH, temL>>, :big) / 4 * 1.007e-2 - 40.0\n    fahren = celsius_to_fahren(celsius)\n    rh = :binary.decode_unsigned(<<Bitwise.band(humH, 0x3f), humL>>, :big) * 6.10e-3\n\n    full_reading_map(fahren, celsius, rh, :none, :none, status)\n  end\n\n  defp hih_decode_status(val) do\n    (val >>> 0x06) &&& 0x03\n  end\n\n# the following code is correct however unused at this point\n\n#  @sht_reset <<0x30, 0xA2>>\n\n#  defp sht_reset(pid) do\n#    I2c.write(pid, @sht_reset)\n#  end\n  defp sht_trigger(:nil), do: full_reading_map(0.0, 0.0, 0.0, :none, :none, :stale)\n  defp sht_trigger(pid) do\n    I2c.write(pid, <<0x2C, 0x06>>)\n    :ok = :timer.sleep(20)\n\n    <<t_raw::16, tchk::8, rh_raw::16, hchk::8>> = I2c.read(pid, 6)\n\n    rh = (rh_raw * 100.0) / ( 1 <<< 16)\n    celsius = (t_raw * 175.0) / ( 1 <<< 16) - 45.0\n    fahren = celsius_to_fahren(celsius)\n\n    full_reading_map(fahren, celsius, rh, sht_checksum_good?(t_raw, tchk), sht_checksum_good?(rh_raw, hchk))\n  end\n\n\n  defp sht_checksum_good?(value, checksum) do\n    case checksum == sht_calc_checksum(value) do\n      true  -> :good\n      false -> :bad\n    end\n  end\n\n  defp sht_calc_checksum(value) do\n    crc = 0xFF\n    msb = value &&& 0x00FF\n    lsb = (value &&& 0xFF00) >>> 8\n    Enum.reduce([lsb, msb], crc, &sht_crc_byte/2)\n  end\n\n  defp sht_crc_byte(byte, crc) do\n    crc = crc ^^^ byte\n    Enum.reduce(1..8, crc, &sht_crc_xor/2)\n  end\n\n  @poly 0x131\n  defp sht_crc_xor(_counter, crc) when band(crc, 0x80) == 0x80 do\n     (crc <<< 1) ^^^ @poly\n  end\n\n  defp sht_crc_xor(_counter, crc) do\n     crc <<< 1\n  end\n\n  defp celsius_to_fahren(celsius) when is_float(celsius) do\n    celsius * (9.0/5.0) + 32.0\n  end\n\n  defp full_reading_map(fahren, celsius, rh, t_chk, rh_chk, status \\\\ :ok)\n  when is_float(fahren) and is_float(celsius) and is_float(rh)\n  and is_atom(t_chk) and is_atom(rh_chk) and is_atom(status) do\n\n    t = %{fahren: Float.round(fahren, 2), celsius: Float.round(celsius,2), checksum: t_chk }\n    r = %{value: Float.round(rh, 1), checksum: rh_chk }\n    %{ts: Timex.now(), read_at: Timex.now(), temp: t, rh: r, status: status}\n  end\n\n  defp do_read_sensor(%State{} = state, name) when is_binary(name) do\n    for reading <- available_readings(name) do\n      device = State.get_sensor_device(state, name)\n      {elapsed_us, full_reading} = :timer.tc(&State.get_reading/2, [state, device])\n\n      val =\n        case reading do\n          @temperature -> full_reading.temp.fahren\n          @humidity    -> full_reading.rh.value\n        end\n\n      checksum =\n        case reading do\n          @temperature -> full_reading.temp.checksum\n          @humidity    -> full_reading.rh.checksum\n        end\n\n      reading_map(elapsed_us, val, name, reading, checksum)\n    end\n  end\n\n  defp no_server(msg) do\n    Logger.warn(\"GenServer.whereis failed for #{msg}\")\n    []\n  end\n\nend\n",
			"file": "i2c_sensor.ex",
			"file_size": 13949,
			"file_write_time": 131334164140000000,
			"settings":
			{
				"buffer_size": 13943,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Package Control Messages\n========================\n\nSublimeLinter-contrib-elixirc\n-----------------------------\n\n  SublimeLinter-contrib-elixirc\n  -------------------------------\n  This linter plugin for SublimeLinter provides an interface to elixirc.\n  \n  ** IMPORTANT! **\n  \n  Before this plugin will activate, you *must*\n  follow the installation instructions here:\n  \n  https://github.com/smanolloff/SublimeLinter-contrib-elixirc\n",
			"settings":
			{
				"buffer_size": 433,
				"line_ending": "Unix",
				"name": "Package Control Messages",
				"read_only": true,
				"scratch": true
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 307.0,
		"last_filter": "pack li",
		"selected_items":
		[
			[
				"pack li",
				"Package Control: List Packages"
			],
			[
				"pack in",
				"Package Control: Install Package"
			],
			[
				"git",
				"Git: Pull"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"pac",
				"Package Control: Install Package"
			],
			[
				"Snippet: ",
				"Snippet: Case Expression"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"Package Control: Install Package",
				"Package Control: Install Package"
			]
		],
		"width": 485.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/thughey/devel/wiss-mcp",
		"/Users/thughey/devel/wiss-mcp/config",
		"/Users/thughey/devel/wiss-mcp/lib",
		"/Users/thughey/devel/wiss-mcp/lib/mcp",
		"/Users/thughey/devel/wiss-mcp/src"
	],
	"file_history":
	[
		"/Users/thughey/devel/wiss-mcp/src/proxr.c",
		"/Users/thughey/devel/wiss-mcp/lib/mcp/sensor_scribe.ex",
		"/Users/thughey/devel/wiss-mcp/lib/mcp/owfs.ex",
		"/Users/thughey/devel/wiss-mcp/lib/mcp/genserver.ex",
		"/Users/thughey/devel/wiss-mcp/lib/mcp/switch.ex",
		"/Users/thughey/devel/wiss-mcp/lib/mcp/i2c_sensor.ex",
		"/Users/thughey/devel/wiss-mcp/lib/mcp/dutycycle.ex"
	],
	"find":
	{
		"height": 23.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"quote"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "i2c_sensor.ex",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13943,
						"regions":
						{
						},
						"selection":
						[
							[
								629,
								629
							]
						],
						"settings":
						{
							"syntax": "Packages/Elixir/Syntaxes/Elixir.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 180.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 433,
						"regions":
						{
						},
						"selection":
						[
							[
								433,
								433
							]
						],
						"settings":
						{
							"auto_indent": false,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_width": 2,
							"word_wrap": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.git-pull":
	{
		"height": 100.0
	},
	"pinned_build_system": "",
	"project": "mcp.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 194.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
